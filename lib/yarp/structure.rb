# frozen_string_literal: true

module Yarp
  # Public: Structure defines a Yarp structure from a given package. This class
  # is normally used by autogenerated code.
  class Structure
    # Public: Sets Yarp metadata for a given structure. Calls to this method are
    # normally autogenerated.
    def self.yarp_meta(id:, package:, name:)
      @yarp_id = id
      @yarp_package = package
      @yarp_name = name
      Registry.register(self)
    end

    # Public: Returns a list of fields for the current structure.
    def self.fields
      @fields || []
    end

    # Internal: Defines a field under a given name and index
    #
    # name  - Name of the field being defined.
    # index - Index of the field being defined.
    #
    # Returns nothing. Raises an exception in case the name or index has already
    # been declared.
    def self.define_field(index, name)
      @fields ||= []
      @known_names ||= []
      @known_indexes ||= []
      raise ArgumentError, "duplicated field name '#{name}'" if @known_names.include? name
      raise ArgumentError, "duplicated index #{index}" if @known_indexes.include? index

      attr_accessor name

      @known_names << name
      @known_indexes << index
      @fields << yield
    end

    # Public: Declares a primitive field with a given name, type, and index.
    # Refer to Yarp's documentation to a list of possible types.
    #
    # Returns nothing. Raises an exception in case the name or index has already
    # been declared.
    def self.primitive(name, type, index, optional: false)
      define_field(index, name) { FieldDescriptor.primitive(name, type, index, optional: optional) }
      define_method("has_#{name}?") { !instance_variable_get("@#{name}").nil? } if optional
    end

    # Public: Declares a map/associative array/hash field with a given name,
    # index, key, and value types.
    # Refer to Yarp's documentation to a list of valid types for both keys and
    # values.
    #
    # Returns nothing. Raises an exception in case the name or index has already
    # been declared.
    def self.map(name, index, key:, value:)
      define_field(index, name) { FieldDescriptor.map(name, index, key, value) }
    end

    # Public: Declares an array field with a given name, index, and type.
    #
    # Returns nothing. Raises an exception in case the name or index has already
    # been declared.
    def self.array(name, index, of:)
      define_field(index, name) { FieldDescriptor.array(name, of, index) }
    end

    # Public: Declares a new struct field with a given name, type, index, and
    # optional indicator.
    #
    # Returns nothing. Raises an exception in case the name or index has already
    # been declared.
    def self.struct(name, type, index, optional: false)
      define_field(index, name) { FieldDescriptor.struct(name, type, index, optional: optional) }
      define_method("has_#{name}?") { !instance_variable_get("@#{name}").nil? } if optional
    end

    # Public: Declares a new oneof field under a given index. A block must be
    # provided to configure the oneof field's fields.
    def self.oneof(index, &block)
      raise LocalJumpError, "no block given" unless block

      descriptor = OneofDescriptor.new
      descriptor.instance_eval(&block)
      reset_all = lambda do |owner|
        descriptor.fields.each do |f|
          owner.instance_variable_set("@#{f.name}", nil)
        end
      end
      descriptor.fields.each do |f|
        idx = [index, f.index]
        name = f.name
        case f.kind
        when :primitive
          primitive(name, f.type, idx)
        when :map
          map(name, idx, key: f.key_type, value: f.value_type)
        when :array
          array(name, idx, of: f.type)
        else
          raise ArgumentError, "invalid field type #{f.field_type}"
        end

        define_method(name) { instance_variable_get("@#{name}") }
        define_method("#{name}=") do |v|
          reset_all[self]
          instance_variable_set("@#{name}", v)
        end
        define_method("has_#{name}?") { !instance_variable_get("@#{name}").nil? }
      end

      @fields ||= []
      @fields << FieldDescriptor.oneof(index, descriptor)
    end

    # Internal: Determines whether the current structure is valid. Raises
    # MinFieldNotZeroError in case the lowest index is not zero, FieldGapError
    # in case non-contiguous fields is detected, and InvalidMetadataError in
    # case the structure provides inconsistent Yarp metadata fields.
    #
    # Returns nothing.
    def self.validate!
      @fields ||= []
      indexes = @fields.map(&:index).reject { |i| i.is_a? Array }.sort
      unless indexes.empty?
        raise MinFieldNotZeroError unless indexes.first.zero?
        raise FieldGapError unless indexes.each_cons(2).all? { |x, y| y == x + 1 }
      end
      raise InvalidMetadataError if @yarp_id.nil? || @yarp_package.nil? || @yarp_name.nil?
    end

    # Public: Initializes a new structure with provided arguments and keyword
    # arguments.
    def initialize(*args, **kwargs)
      @unknown_fields = []
      args.each_with_index { |v, i| set_by_index(i, v) }
      kwargs.each_pair { |k, v| set_by_name(k, v) }
    end

    attr_accessor :unknown_fields

    private

    # Internal: Obtains an index through a given indexer and value comparator.
    # Returns a field matching provided criteria, or nil, in case none is found.
    def field_by(indexer, value)
      self.class.fields.find { |field| field.send(indexer) == value }
    end

    # Internal: Sets a field's value by its name.
    def set_by_name(name, value)
      name = name.to_sym
      f = field_by(:name, name)
      return handle_unknown(:field, name, value) unless f

      set_by_field(f, value)
    end

    # Internal: Sets a field's value by its index.
    def set_by_index(index, value)
      f = field_by(:index, index)
      return handle_unknown(:index, index, value) unless f

      set_by_field(f, value)
    end

    # Internal: Handles an attempt of setting an unknown field as configured.
    def handle_unknown(kind, name, _value)
      case Yarp.handle_unknown_field_initialization_with
      when :warn
        warn "[Yarp] Attempt to set unknown #{kind} #{name} for #{self.class.inspect}"
      when :exception
        raise UnknownFieldInitializationError, "Attempt to set unknown #{kind} #{name} for #{self.class.inspect}"
      end
      false
    end

    # Internal: Sets a field through its descriptor and value.
    def set_by_field(field, value)
      setter = "#{field.name}="
      case field.kind
      when :primitive, :map
        send(setter, value)
      when :array
        send(setter, value.map { |v| Proto.convert!(v, field.type) })
      when :struct
        send(setter, Proto.convert!(value, field.type))
      end
    end
  end
end
