# frozen_string_literal: true

require_relative "client/configuration"
require_relative "client/io_injector"

module Yarp
  # Public: Client implements the basic logic for a Yarp client. This class is
  # normally inherited by autogenerated clients and is not intended for direct
  # use.
  class Client
    def self.configure
      inst = Yarp::Client::Configuration.instance
      return inst unless block_given?

      yield inst
      nil
    end

    attr_reader :headers

    def headers=(value)
      @headers = value || {}
    end

    def initialize(address, **opts)
      @config = Yarp::Client::Configuration.instance.dup
      opts.each { |k, v| @config.send("#{k}=", v) if @config.respond_to? "#{k}=" }

      @uri = URI(address)
      @scheme = @uri.scheme.downcase.to_sym
      @headers = opts.delete(:headers) || {}

      unless %i[tcp unix].include? @scheme
        raise ArgumentError, "Invalid address #{address}: " \
                             "Invalid scheme #{@uri.scheme}. " \
                             "Valid options are tcp, unix"
      end

      return if @scheme != :tcp

      family_limit = nil
      family_limit = Socket::PF_INET if @config.prefer_ipv4
      if @config.prefer_ipv6
        if family_limit.nil?
          family_limit = Socket::PF_INET6
        else
          family_limit |= Socket::PF_INET6
        end
      end
      @tcp_address = Addrinfo.getaddrinfo(@uri.host, nil, family_limit, :STREAM,
                                          timeout: @config.resolve_timeout_sec).first
    end

    def configure(&block)
      @config.instance_exec(&block)
    end

    protected

    def generate_tls_config
      ssl_options = OpenSSL::SSL::OP_ALL
      if defined?(OpenSSL::SSL::OP_NO_SSLv2) && !@config.tls_ssl_version.include?(:SSLv2)
        ssl_options |= OpenSSL::SSL::OP_NO_SSLv2
      end
      if defined?(OpenSSL::SSL::OP_NO_SSLv3) && !@config.tls_ssl_version.include?(:SSLv3)
        ssl_options |= OpenSSL::SSL::OP_NO_SSLv3
      end
      if defined?(OpenSSL::SSL::OP_NO_TLSv1) && !@config.tls_ssl_version.include?(:TLSv1)
        ssl_options |= OpenSSL::SSL::OP_NO_TLSv1
      end
      if defined?(OpenSSL::SSL::OP_NO_TLSv1_1) && !@config.tls_ssl_version.include?(:TLSv1_1)
        ssl_options |= OpenSSL::SSL::OP_NO_TLSv1_1
      end
      if defined?(OpenSSL::SSL::OP_NO_TLSv1_2) && !@config.tls_ssl_version.include?(:TLSv1_2)
        ssl_options |= OpenSSL::SSL::OP_NO_TLSv1_2
      end
      params = { ssl_options: ssl_options }
      params[:cert_chain] = @config.tls_cert_chain_file unless @config.tls_cert_chain_file.nil?
      params
    end

    def connect
      case @scheme
      when :tcp
        Socket.new(@tcp_address.afamily, @tcp_address.socktype).tap do |s|
          unless @config.read_timeout_sec.nil?
            s.setsockopt Socket::SOL_SOCKET, Socket::SO_RCVTIMEO, @config.pack_read_timeout
          end

          unless @config.write_timeout_sec.nil?
            s.setsockopt Socket::SOL_SOCKET, Socket::SO_SNDTIMEO, @config.pack_write_timeout
          end

          s.connect(Socket.pack_sockaddr_in(@uri.port || 9277, @tcp_address.ip_address))
        end

      when :unix
        Socket.unix(@uri.path).tap do |s|
          unless @config.read_timeout_sec.nil?
            s.setsockopt Socket::SOL_SOCKET, Socket::SO_RCVTIMEO, @config.pack_read_timeout
          end
          unless @config.write_timeout_sec.nil?
            s.setsockopt Socket::SOL_SOCKET, Socket::SO_SNDTIMEO, @config.pack_write_timeout
          end
        end
      end
    end

    def configure_tls(io)
      return io unless @config.use_tls

      tls_config = generate_tls_config
      ctx = OpenSSL::SSL::SSLContext.new
      ctx.options = tls_config[:ssl_options]
      ctx.cert = OpenSSL::X509::Certificate.new(tls_config[:cert_chain]) if tls_config[:cert_chain]
      ctx.ciphers = tls_config[:cipher_list] if tls_config[:cipher_list]
      OpenSSL::SSL::SSLSocket.new(io, ctx).tap { |s| s.sync_close = true }
    end

    def exchange(data)
      io = configure_tls(connect)
      io.connect if io.is_a? OpenSSL::SSL::SSLSocket

      IO.copy_stream(data, io)

      resp_type = io.read(3)
      case resp_type
      when Yarp::Proto::MAGIC_RESPONSE
        handler = Yarp::Proto::Response
      when Yarp::Proto::MAGIC_ERROR
        handler = Yarp::Proto::Error
      else
        raise Yarp::CorruptStreamError
      end
      result = handler.decode(IOInjector.new(resp_type, io))
      raise result if result.is_a? Yarp::Proto::Error

      results = []
      loop do
        break if io.eof?

        v = Yarp::Proto.decode_any(io)
        return [result.headers, v] unless result.stream?

        if block_given?
          yield v, result.headers
          next
        end
        results << v
      end
      return nil if block_given?

      [result.headers, results]
    ensure
      io&.close
    end

    def exec(method_id, body, &block)
      req = Yarp::Proto::Request.new(method_id, @headers)
      buf = StringIO.new
      req.encode(buf)
      Yarp::Proto.encode(buf, body)
      buf.rewind
      exchange(buf, &block)
    end
  end
end
